/**
 * Copyright (C) 2013 Tokanagrammar Team
 *
 * This is a jigsaw-like puzzle game,
 * except each piece is token from a source file,
 * and the 'complete picture' is the program.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Define a simple grammar for scanning Java source files
 * (Derived from the J--'s parser)
 *
 * This will scan, and record the tokens to build a <code>SourceFile</code>
 * object.
 *
 * Note: As of this release (post-1.0), the class does NOT perform grammar checking.
 * The compilability of the source file will be checked by delegating to the
 * `javac`
 *
 * @author Vy Thao Nguyen
 */

options 
{
    // multiple instances are allowed
    STATIC = false ;
}

PARSER_BEGIN(JavaParser)

package edu.umb.cs.parser;

import edu.umb.cs.source.SourceFile;
import edu.umb.cs.source.SourceToken;
import edu.umb.cs.source.std.*;
import java.util.ArrayList;
import java.util.List;



public class JavaParser
{
    private static final char NOT_SET = 0;


    private SourceToken keyword(String img)
    {
        // TODO: cache keywords and reuse them
        return new KeywordToken(img);
    }

    private SourceToken separator(String img)
    {
        // TODO cache brackets and reuse them
        // might not be identifier
        return new IdentifierToken(img);
    }

    private SourceToken semi()
    {
        return OperatorToken.getOperator(";");
    }

    private SourceToken operator(String img)
    {
        // TODO validate?
        return OperatorToken.getOperator(img);
    }

    private SourceToken tab()
    {
        return TabToken.INSTANCE;
    }

    private SourceToken space()
    {
        return SpaceToken.INSTANCE;
    }

    private SourceToken identifier(String img)
    {
        return new IdentifierToken(img);
    }

    private boolean basicTypeFollows()
    {
        switch(getToken(1).kind)
        {
            case VOID:
            case BOOLEAN:
            case CHAR:
            case BYTE:
            case SHORT:
            case INT:
            case LONG:
            case FLOAT:
            case DOUBLE:
                return true;
             default:
                return false;
        }
    }

    private boolean referenceTypeFollows()
    {
        if (basicTypeFollows())
            return getToken(2).kind == LBRACK;
            
        return getToken(2).kind == IDENTIFIER;
    }

    private boolean typeFollows()
    {
        return basicTypeFollows() || referenceTypeFollows();
    }

    private boolean methodDeclFollows()
    {
        if (!typeFollows())
            return false;

        return getToken(2).kind == IDENTIFIER
                    && getToken(3).kind == LPAREN;
    }

}
PARSER_END(JavaParser)


////////////////// TOKENS definition////////////////////////

// Whitespace -- ignored
SKIP: {" "|"\t"|"\n"|"\r"|"\f"}

// Single line comment -- ignored
SKIP: {<SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>}


// Reserved words
TOKEN:
{
  < ABSTRACT: "abstract" >
| < BOOLEAN: "boolean" >
| < BYTE: "byte" >
| < CHAR: "char" >
| < CLASS: "class" >
| < DO : "do" >
| < DOUBLE : "double" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FLOAT: "float" >
| < IF: "if" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < LONG: "long" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < SUPER: "super" >
| < THIS: "this" >
| < THROWS: "throws" >
| < TRUE: "true" >
| < VOID: "void" >
| < WHILE: "while" >
}

// Operators (these could be combined with the reserved words)
TOKEN:
{
  < PLUS: "+" >
| < ASSIGN: "=" >
| < DIV: "/" >
| < DEC: "--" >
| < EQUAL: "==" >
| < GT: ">" >
| < INC: "++" >
| < LAND: "&&" >
| < LE: "<=" >
| < LNOT: "!" >
| < MINUS: "-" >
| < PERCENT: "%" >
| < PLUS_ASSIGN: "+=" >
| < STAR: "*" >
}

// Separators (these could be combined with the reserved words)
TOKEN:
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LCURLY: "{" >
| < RCURLY: "}" >
| < LBRACK: "[" >
| < RBRACK: "]" >
| < SEMI: ";" >
| < COMMA: "," >
| < DOT: "." >
}

// Identifiers
TOKEN:
{
  < IDENTIFIER: (<LETTER>|"_"|"$") (<LETTER>|<DIGIT>|"_"|"$")* >
| < #LETTER: ["a"-"z","A"-"Z"] >
| < #DIGIT: ["0"-"9"] >
| < #NON_ZERO_DIGIT: ["1"-"9"] >
}

// Literals
TOKEN:
{
  < INT_LITERAL: ("0" | <NON_ZERO_DIGIT> ((<UNDERSCORE>)* <DIGIT>)*) >
| < LONG_LITERAL: <INT_LITERAL> <L> >
| < HEX_INT_LITERAL: ("0x" | "0X") (<HEX_DIGIT>  ((<UNDERSCORE>)+ <HEX_DIGIT>)* )+ >
| < HEX_LONG_LITERAL: <HEX_INT_LITERAL> <L> >
| < OCT_INT_LITERAL: "0" (<OCT_DIGIT> ((<UNDERSCORE>)+ <HEX_DIGIT>)* )+ >
| < OCT_LONG_LITERAL: <OCT_INT_LITERAL> <L> >
| < BIN_INT_LITERAL: "0b" (<BIN_DIGIT> ((<UNDERSCORE>)+ <BIN_DIGIT>)* )+ >
| < BIN_LONG_LITERAL: <BIN_INT_LITERAL> <L> >
| < CHAR_LITERAL: "'" (<ESC> | ~["'","\\","\n","\r"]) "'" >
| < STRING_LITERAL: "\"" (<ESC> | ~["\"","\\","\n","\r"])* "\"" >   
| < #UNDERSCORE: "_" >
| < #L: ("l"| "L") >
| < #D: ("d" | "D") >
| < #F: ("f" | "F" ) >
| < #ESC: "\\" ["n","t","b","r","f","\\","'","\""] >
| < #HEX_DIGIT: ["a"-"f", "A"-"F", "0"-"9"] >
| < #OCT_DIGIT: ["0"-"7"] >
| < #BIN_DIGIT: ["0"-"1"] >
}

// types
TOKEN:
{
    < PRIMATIVE: ( <VOID> | <CHAR> | <BOOLEAN> | <BYTE> | <SHORT> | <INT> | <LONG> | <DOUBLE> | <FLOAT> ) >
|   < REFERENCE: ( <PRIMATIVE> (<LBRACK> <RBRACK>)+ | <IDENTIFIER> (<LBRACK> <RBRACK>)* ) >    
}

// For anything else, we return an ERROR token. Without this 
// definition the TokenManager will throw an Error when a lexical 
// error occurs, making it impossible to recover from it. So we 
// define this ERROR token. 
TOKEN:
{
 < ERROR: ~[] >
}

////////////////////////////////////////////////////////
//   Grammar starts here
///////////////////////////////////////////////////////

/**
 *
 * <pre>
 *   compilationUnit ::= [PACKAGE qualifiedIdentifier SEMI]
 *                       {IMPORT  qualifiedIdentifier SEMI}
 *                       {typeDeclaration}
 *                       EOF 
 * </pre>
 */
SourceFile
parseJava():
{
    int tkCount[] = new int[] {0};
    int line = 0;
    List<List<SourceToken>> srcFile = new ArrayList<List<SourceToken>>();
    List<SourceToken> curLine = null;
}
{
    [
        <PACKAGE>
        {
            tkCount[0] += 2;
            curLine = new ArrayList<SourceToken>();
            curLine.add(keyword("package"));
            curLine.add(space());
            srcFile.add(curLine);
        }
        qualifiedIdentifier (srcFile.get(line), tkCount)
        <SEMI>
        {
            ++tkCount[0];
            srcFile.get(line).add(semi());
            ++line;
        }
    ]
    (
        <IMPORT>
        {
            tkCount[0] += 2;
            curLine = new ArrayList<SourceToken>();
            curLine.add(keyword("import"));
            curLine.add(space());
            srcFile.add(curLine);    
        }
        qualifiedIdentifier(srcFile.get(line), tkCount)
        <SEMI>
        {
            ++tkCount[0];
            srcFile.get(line).add(semi());
            ++line;
        }
    )*
    (
          line = typeDeclaration(srcFile, line, tkCount)
    )*
    <EOF>
    {
        return new JavaSourceFile("TODO", srcFile, tkCount[0]);
    }
}

private
void
qualifiedIdentifier (List<SourceToken> srcLine, int tkCount[]) :
{
}
{
    <IDENTIFIER>
    {
        ++tkCount[0];
        srcLine.add(identifier(token.image));
    }
    (LOOKAHEAD ( { getToken(1).kind == DOT } )
        <DOT><IDENTIFIER>
        {
            tkCount[0] += 2;
            srcLine.add(seperator("."));
            srcLine.add(identifier(token.image));
        }
    )*
}

/**
 * Parse a type declaration.
 * 
 * <pre>
 *   typeDeclaration ::= modifiers classDeclaration
 * </pre>
 * 
 */
private
int
typeDeclaration(List<List<SourceToken>> src, int line, int count[]) :
{
    List<SourceToken> curLine = new ArrayList<SourceToken>();
    src.add(curLine);
}
{
    modifiers(curLine, count)
    line = classDeclaration(src, line, count, 0)
    {
        return line;
    }
}

/**
 * Parse modifiers.
 * 
 * <pre>
 *   modifiers ::= {PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT}
 * </pre>
 * 
 * 
 */

private
void
modifiers(List<SourceToken> curLine, int count[]) :
{
}
{   
    
    (
        ( <PUBLIC> | <PROTECTED> | <PRIVATE> | <STATIC> | <ABSTRACT> )
        { 
            count[0] += 2;
            curLine.add(keyword(token.image));
            curLine.add(space());
        }
    )*
    {
        return;
    }
}

/**
 * Parse a class declaration
 *
 * <pre>
 *   classDeclaration ::= CLASS IDENTIFIER 
 *                        [EXTENDS qualifiedIdentifier] 
 *                        classBody
 * </pre>
 *
 */
private
int
classDeclaration(List<List<SourceToken>> src, int line, int count[], int level) :
{
    List<SourceToken> curLine = null;
}
{
    <CLASS>
    {
        count[0] += 2;
        curLine = src.get(line);
        curLine.add(keyword("class"));
        curLine.add(space());
    }
    <IDENTIFIER>
    {
        ++count[0];
        curLine.add(identifier(token.image));
    }
    [
        <EXTENDS>
        {
            count[0] += 3;
            curLine = src.get(line);
            curLine.add(space());
            curLine.add(keyword("extends"));
            curLine.add(space());
        }
        qualifiedIdentifier(src.get(line), count)
    ]
    {
        ++line;
    }
    line = classBody(src, line, count, level)
    {
        return line;
    }
}

/**
 * Parse a class body.
 * 
 * <pre>
 *   classBody ::= LCURLY
 *                   {modifiers memberDecl}
 *                 RCURLY
 * </pre>
 * 
 * @return list of members in the class body.
 */
private
int
classBody (List<List<SourceToken>> src, int line, int count[], int level) :
{
    int n = 0;
    List<SourceToken> curLine = new ArrayList<SourceToken>();
    while (n++ < level)
    {
        ++count[0];
        curLine.add(tab());
    }
}
{
    (
        <LCURLY>
        {
            count[0] += 2;
            curLine.add(separator("{"));
            src.add(curLine);
            ++line;
            curLine = new ArrayList<SourceToken>();
            ++level;
            n = 0;
            while (n++ < level)
            {
                ++count[0];
                curLine.add(tab());
            }
            src.add(curLine);
        }
        (
            modifiers(src.get(line), count)
            line = memberDecl(src, line, count, level)
            {
                curLine = new ArrayList<SourceToken>();
                n = 0;
                while (n++ < level)
                {
                    ++count[0];
                    curLine.add(tab());
                }
                src.add(curLine);
            }
        )*
        <RCURLY>
        {
            --level;
            n = 0;
            curLine = new ArrayList<SourceToken>();
            while (n++ < level)
            {
                ++count[0];
                curLine.add(tab());
            }
            curLine.add(separator("}"));
            src.add(curLine);
            ++line;
        }
    )
    {
        return line;
    }
        
}

/**
 * Parse a member declaration.
 * 
 * <pre>
 *   memberDecl ::= IDENTIFIER            // constructor
 *                    formalParameters
 *                    block
 *                | (PRIMATIVE | REFERENCE) IDENTIFIER  // method
 *                    formalParameters
 *                    (block | SEMI)
 *                | type variableDeclarators SEMI 
 * </pre>
 *
 */
private
int
memberDecl(List<List<SourceToken>> src, int line, int count[], int level) :
{
    List<SourceToken> curLine = null;
    int n = 0;
}
{
    ( 
        LOOKAHEAD ( <IDENTIFIER> <LPAREN> )
        (
            <IDENTIFIER>
            {
                ++count[0];
                curLine = src.get(line);
                curLine.add(identifier(token.image));
                curLine.add(space());
                ++count[0];
            }
            formalParameters(curLine, count)
            {
                ++line;
            }
            line = block(src, line, count, level)
        )
        |
        LOOKAHEAD ( (<PRIMATIVE> | <REFERENCE>) <IDENTIFIER> <LPAREN>)
        (
            type(src.get(line), count)
            {
                src.get(line).add(space());
                ++count[0];
            }
            <IDENTIFIER>
            {
                ++count[0];
                curLine = src.get(line);
                curLine.add(identifier(token.image));
                curLine.add(space());
                ++count[0];
            }
            formalParameters(curLine, count)
            // TODO add declared exceptions HERE
            {
                ++line;
            }
            (
                <SEMI>
                {
                    // put SEMI on previous line
                    --line;
                    src.get(line).add(semi());
                    ++count[0];
                }
            |  
                line = block(src, line, count, level)
            )
        )
    |
        (
            type(curLine = src.get(line), count)
            {
                curLine.add(space());
                ++count[0];
            }
            variableDeclarators(curLine, count)
            <SEMI>
            {
                curLine.add(semi());
                ++count[0];
            }
        )
    )
    {
        return line;
    }
}

/**
 * parse formal parameters
 * 
 * <pre>
 *   formalParameters ::= LPAREN 
 *                          [formalParameter 
 *                            {COMMA  formalParameter}]
 *                        RPAREN
 * </pre>
 * 
 */
private
void
formalParameters(List<SourceToken> curLine, int count[]) :
{
}
{
    <LPAREN>
    {
        curLine.add(separator("("));
        ++count[0];
    }
    [
        formalParameter(curLine, count)
        (
            <COMMA>
            {
                curLine.add(separator(","));
                ++count[0];
                curLine.add(space());
                ++count[0];
            }
            formalParameter(curLine, count)
        )*
    ]
    <RPAREN>
    {
        curLine.add(separator(")"));
        ++count[0];
        return;
    }
}

/**
 * Parse a formal parameter.
 * 
 * <pre>
 *   formalParameter ::= type IDENTIFIER
 * </pre>
 * 
 */
private
int
void
formalParameter(List<SourceToken> curLine, int count[]) :
{
}
{
    type(curLine, count)
    {
        curLine.add(space());
        ++count[0];
    }
    <IDENTIFIER>
    {
        curLine.add(identifier(token.image));
        ++count[0];
    }
}


/**
 * Parse a type.
 * 
 * <pre>
 *   type ::= PRIMATIVE 
 *          | REFERENCE
 * </pre>
 * 
 */
private
void
type(List<SourceToken> curLine, int count[]) :
{
}
{
    <PRIMATIVE>
    {
        curLine.add(keywords(token.image));
        ++count[0];
    }
|
    <REFERENCE>
    {
        curLine.add(identifier(token.image));
        ++count[0];
    }
}

/**
 * Parse variable declarators.
 * 
 * <pre>
 *   variableDeclarators ::= variableDeclarator 
 *                             {COMMA variableDeclarator}
 * </pre>
 * 
 * @param current line, token count
 */

private
void
variableDeclarators (List<SourceToken> curLine, int count[]) :
{
}
{
    variableDeclarator(curLine, count)
    (
        <COMMA>
        {
            curLine.add(seperator(","));
            ++count[0];
            curLine.add(space());
            ++count[0];
        }
        variableDeclarator(curLine, count)
    )*
}

/**
 * Parse a variable declarator.
 * 
 * <pre>
 *   variableDeclarator ::= IDENTIFIER
 *                          [ASSIGN variableInitializer]
 * </pre>
 * 
 */

private
void
variableDeclarator (List<SourceToken> curLine, int count[]) :
{
}
{
    <IDENTIFIER>
    {
        curLine.add(identifer(token.image));
        ++count[0];
    }
    [
        <ASSIGN>
        {
            curLine.add(space());
            curLine.add(operator("="));
            curLine.add(space());
            count[0] += 3;
        }
        variableInitializer(curLine, count)
    ]
}

/**
 * Parse a variable initializer.
 * 
 * <pre>
 *   variableInitializer ::= arrayInitializer
 *                         | expression
 * </pre>
 *
 */
private
void
variableInitializer (List<SourceToken> curLine, int count[]) :
{
}
{
    arrayInitializer(curLine, count) | expression(curLine, count)
}

/**
 * Parse an array initializer.
 * 
 * <pre>
 *   arrayInitializer ::= LCURLY 
 *                          [variableInitializer 
 *                            {COMMA variableInitializer} [COMMA]]
 *                        RCURLY 
 * </pre>
 * 
 */

private
void
arrayInitializer(List<SourceToken> curLine, int count[]) :
{
}
{
    try {
        <LCURLY> { line = token.beginLine; }
        [ 
            anInitializer = 
              variableInitializer( expected.componentType() ) 
            { initials.add( anInitializer ); }
            ( 
                <COMMA> anInitializer = 
                    variableInitializer( expected.componentType() ) 
                { initials.add( anInitializer ); } 
            )* 
        ] 
        <RCURLY>
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return new JArrayInitializer( line, expected, initials ); }
}

private
int
block (List<List<SourceToken>> src, int line, int count[], int level) :
{
    List<SourceToken> cur;
    int n;
}
{
     (<LCURLY>
     <RCURLY>)
     {
        cur = new ArrayList<SourceToken>();
        n = 0;
        while (n++ < level)
            cur.add(tab());
        cur.add(separator("{"));
        ++count[0];
        src.add(cur);
        ++line;
        

        cur = new ArrayList<SourceToken>();
        n = 0;
        while (n++ < level)
            cur.add(tab());
        cur.add(separator("}"));
        ++count[0];
        src.add(cur);
        ++line;
        
        return line;
     }
}